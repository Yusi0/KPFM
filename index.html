<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KPFM</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto', Arial, sans-serif;
            background-color: #121212;
            /* 다크모드 배경색 */
            margin: 0;
            color: #E0E0E0;
            /* 밝은 텍스트 */
        }

        .container {
            width: 90%;
            max-width: 1000px;
            background: #1E1E1E;
            /* 다크모드 박스 배경 */
            border-radius: 12px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            padding: 30px;
            margin: 30px auto;
            overflow: hidden;
        }

        h1 {
            font-size: 28px;
            font-weight: 700;
            text-align: center;
            color: #BB86FC;
            /* 포인트 컬러 */
            margin-bottom: 25px;
        }

        .search-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        input {
            width: 100%;
            max-width: 400px;
            padding: 12px;
            font-size: 16px;
            border: 1px solid #333;
            border-radius: 8px;
            background-color: #1E1E1E;
            color: #E0E0E0;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
        }

        input:focus {
            outline: none;
            border-color: #BB86FC;
            box-shadow: 0 4px 12px rgba(187, 134, 252, 0.3);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            background-color: #1E1E1E;
            border-radius: 8px;
            overflow: hidden;
        }

        th,
        td {
            padding: 15px;
            text-align: center;
            border: 1px solid #333;
            color: #E0E0E0;
        }

        th {
            background-color: #333;
            /* 테이블 헤더 배경 */
            color: #BB86FC;
            /* 헤더 텍스트 */
            font-weight: 700;
        }

        tbody tr {
            background-color: #2C2C2C;
            /* 테이블 행 배경 */
            transition: all 0.3s ease;
        }

        tbody tr:hover {
            background-color: #3C3C3C;
            transform: scale(1.01);
            box-shadow: 0 0 10px rgba(187, 134, 252, 0.5);
        }


        tbody tr:nth-child(even) {
            background-color: #323232;
            /* 줄무늬 행 */
        }

        tbody tr td:first-child {
            font-weight: 700;
            font-size: 16px;
            color: #FFD700;
            /* 순위 포인트 컬러 */
        }

        tbody tr td:last-child {
            font-weight: 700;
            color: #BB86FC;
        }

        tbody tr td:nth-child(2) {
            font-weight: 700;
            color: #BB86FC;
        }

        .tier {
            font-weight: 700;
            color: #9c4bff;
            /* 포인트 컬러 */
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>KPFM Leaderboard</h1>
        <div class="search-container">
            <input type="text" id="searchBox" placeholder="Search user..." list="nicknameList">
            <datalist id="nicknameList"></datalist>
        </div>
        <table id="leaderboard">
            <thead>
                <tr>
                    <th>순위</th>
                    <th>닉네임</th>
                    <th>KDR</th>
                    <th>승률</th>
                    <th>KPR</th>
                    <th>매치 수</th>
                    <th>ELO</th>
                    <th>티어</th>
                </tr>
            </thead>
            <tbody>
                <!-- Leaderboard rows will be dynamically generated -->
            </tbody>
        </table>
    </div>

    <script>
        let leaderboardData = [];

        fetch('https://yusi0.github.io/KPFM/match.csv')
            .then(response => response.text())
            .then(data => {
                const rows = data.trim().split('\n');
                const headers = rows[0].split(',').map(header => header.trim());
                const matches = rows.slice(1).map(row => {
                    const values = row.split(',').map(value => value.trim());
                    return Object.fromEntries(headers.map((header, index) => [header, values[index]]));
                });
                processMatches(matches);
            })
            .catch(error => console.error("Error loading CSV:", error));

        document.getElementById("searchBox").addEventListener("input", function () {
            const input = this.value.trim().toLowerCase();
            const minChars = 4; // 최소 입력 글자 수
            const dataList = document.getElementById("nicknameList");
            dataList.innerHTML = ''; // 기존 옵션 초기화

            if (input.length >= minChars) {
                const matchingPlayers = leaderboardData.filter(player => player.nickname.toLowerCase().startsWith(input));
                matchingPlayers.forEach(player => {
                    const option = document.createElement("option");
                    option.value = player.nickname;
                    dataList.appendChild(option);
                });

                // 첫 번째 매칭된 플레이어의 닉네임 가져오기
                if (matchingPlayers.length > 0) {
                    const nickname = matchingPlayers[0].nickname; // 첫 번째 일치 항목의 닉네임
                    window.location.href = `user.html?nickname=${encodeURIComponent(nickname)}`;
                }
            }
        });
        function processMatches(matches) {
            const playerStats = {};

            matches.forEach(match => {
                const nickname = match.Nickname;
                if (!nickname) return;

                const team = parseInt(match.Team, 10) || 0; // 숫자로 변환
                const kills = parseInt(match.Kills, 10) || 0;
                const deaths = parseInt(match.Deaths, 10) || 0;
                const opponentElo = parseInt(match['Opponent ELO'], 10) || 1500; // 기본값 1500
                const winningTeam = parseInt(match['Winning Team'], 10) || 0;
                const result = team === winningTeam ? 1 : 0;

                if (!playerStats[nickname]) {
                    playerStats[nickname] = {
                        nickname,
                        matches: 0,
                        kills: 0,
                        deaths: 0,
                        wins: 0,
                        losses: 0,
                        elo: 1500, // 초기 ELO
                    };
                }

                const player = playerStats[nickname];
                player.matches += 1;
                player.kills += kills;
                player.deaths += deaths;
                if (result === 1) player.wins += 1;
                else player.losses += 1;

                player.elo = calculateElo(player.elo, opponentElo, result, kills, deaths, player.matches, player.wins);
                player.tier = calculateTier(player.elo);
            });

            leaderboardData = Object.values(playerStats);
            renderLeaderboard(leaderboardData);
        }

        function renderLeaderboard(data) {
            const tbody = document.querySelector("#leaderboard tbody");
            tbody.innerHTML = '';

            data.sort((a, b) => b.elo - a.elo).forEach((player, index) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${index + 1}</td>
                    <td>${player.nickname}</td>
                    <td>${(player.kills / Math.max(1, player.deaths)).toFixed(2)}</td>
                    <td>${((player.wins / player.matches) * 100).toFixed(1)}%</td>
                    <td>${(player.kills / player.matches).toFixed(1)}</td>
                    <td>${player.matches}</td>
                    <td>${player.elo}</td>
                    <td>${player.tier}</td>
                `;
                tbody.appendChild(row);
            });
        }

        function calculateElo(playerElo, opponentElo, result, kills, deaths, totalMatches, wins, k = 50, killWeight = 0.2, deathWeight = 0.1, initialK = 50) {
            if (deaths === 0) deaths = 1; // 데스가 0인 경우 방지

            const expectedResult = 1 / (1 + 10 ** ((opponentElo - playerElo) / 400));
            const baseK = totalMatches <= 5 ? initialK : k / (1 + totalMatches / 20);

            const winLossFactor = result === 1 ? 1 : -1;
            const eloChange = baseK * winLossFactor * (1.5 - expectedResult);
            const performanceScore = kills * killWeight - deaths * deathWeight;

            const newElo = playerElo + eloChange + performanceScore;
            return Math.max(0, Math.round(newElo));
        }

        function calculateTier(elo) {
            const baseElo = 1500;
            const tierNames = [
                "Copper 3", "Copper 2", "Copper 1",
                "Bronze 3", "Bronze 2", "Bronze 1",
                "Silver 3", "Silver 2", "Silver 1",
                "Gold 3", "Gold 2", "Gold 1",
                "Platinum 3", "Platinum 2", "Platinum 1",
                "Diamond 3", "Diamond 2", "Diamond 1",
                "Champion 3", "Champion 2", "Champion 1"
            ];

            const tierIndex = Math.min(Math.max(Math.floor((elo - baseElo) / 100) + 9, 0), tierNames.length - 1);
            return tierNames[tierIndex];
        }
    </script>
</body>

</html>
