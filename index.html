<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Si0 Survival</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; background: #000; }
        #gameOverScreen, #levelUpScreen, #mainMenu {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            font-size: 48px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        #restartButton, .skillButton, #playButton {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 24px;
            background-color: #fff;
            color: #000;
            border: none;
            cursor: pointer;
        }
        #bulletDamageLabel, #skillsLabel, #statusLabel, #enemyCountLabel {
            position: absolute;
            color: white;
            font-size: 18px;
        }
        #bulletDamageLabel {
            bottom: 10px;
            right: 10px;
        }
        #skillsLabel {
            top: 10px;
            left: 10px;
        }
        #statusLabel {
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
        }
        #enemyCountLabel {
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
        }
        .skillButton {
            margin-top: 10px;
        }
        .skillDescription {
            font-size: 16px;
            color: white;
            text-align: center;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="gameOverScreen">
        <div>Game Over</div>
        <button id="restartButton">Restart</button>
    </div>
    <div id="levelUpScreen">
        <div>Level Up!</div>
        <button class="skillButton" data-skill="shotgun">Shotgun</button>
        <div class="skillDescription" data-skill="shotgun">거리가 멀어질 수록 약해지는 펠릿 2개가 추가됩니다.</div>
        <button class="skillButton" data-skill="rpm">RPM</button>
        <div class="skillDescription" data-skill="rpm">연사력이 빨라집니다.</div>
        <button class="skillButton" data-skill="burst">Burst</button>
        <div class="skillDescription" data-skill="burst">탄이 하나 더 발사됩니다.</div>
        <button class="skillButton" data-skill="hermes">Hermes</button>
        <div class="skillDescription" data-skill="hermes">이동 속도가 빨라집니다.</div>
        <button class="skillButton" data-skill="magnetic">Magnetic</button>
        <div class="skillDescription" data-skill="magnetic">아이템 획득 범위가 증가합니다.</div>
        <button class="skillButton" data-skill="range">Range</button>
        <div class="skillDescription" data-skill="range">플레이어 시야 범위가 증가합니다.</div>
        <button class="skillButton" data-skill="damage">Damage</button>
        <div class="skillDescription" data-skill="damage">대미지가 10 증가합니다.</div>
    </div>
    <div id="bulletDamageLabel">Bullet Damage: 5</div>
    <div id="skillsLabel">Shotgun: 0<br>RPM: 0<br>Burst: 0<br>Hermes: 0<br>Magnetic: 0<br>Range: 0<br>Damage: 0</div>
    <div id="statusLabel">Time: 0s | Wave: 1 | Time until next wave: 30s</div>
    <div id="enemyCountLabel">Enemies: 0</div>
    <div id="mainMenu">
        <div>Si0 Survival</div>
        <button id="playButton">Play</button>
    </div>
    <audio id="bgm" loop>
        <source src="your_bgm_file_path.mp3" type="audio/mpeg">
    </audio>
    <audio id="laserSound">
        <source src="your_laser_sound_file_path.mp3" type="audio/mpeg">
    </audio>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const restartButton = document.getElementById('restartButton');
        const levelUpScreen = document.getElementById('levelUpScreen');
        const skillButtons = document.querySelectorAll('.skillButton');
        const skillDescriptions = document.querySelectorAll('.skillDescription');
        const bulletDamageLabel = document.getElementById('bulletDamageLabel');
        const skillsLabel = document.getElementById('skillsLabel');
        const statusLabel = document.getElementById('statusLabel');
        const enemyCountLabel = document.getElementById('enemyCountLabel');
        const mainMenu = document.getElementById('mainMenu');
        const playButton = document.getElementById('playButton');
        const bgm = document.getElementById('bgm');
        const laserSound = document.getElementById('laserSound');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const mapSize = 3000;  // 맵 크기
        const viewSize = 1000; // 화면 크기

        let player, enemies, keys, bullets, expOrbs, medKits, wave, waveTime, enemySpawnInterval, lastEnemySpawn, bossSpawned;
        let gameOver = false;
        let invincible = false;
        let invincibleTimer = 0;
        let exp = 0;
        let level = 0;
        let bulletDamage = 5;
        let shotgun = 0;
        let rpm = 0;
        let burst = 0;
        let hermes = 0;
        let magnetic = 0;
        let range = 0;
        let damage = 0;
        let lastShot = 0;
        let playerDirection = 0;
        let expToNextLevel = 20;
        let mouseX = canvas.width / 2;
        let mouseY = canvas.height / 2;
        let startTime, elapsedTime;

        const trees = [];

        function initializeGame() {
            player = { x: mapSize / 2, y: mapSize / 2, size: 20, speed: 1.2, health: 100, viewRange: 300 };
            enemies = [];
            keys = {};
            bullets = [];
            expOrbs = [];
            medKits = [];
            wave = 1;
            waveTime = 30 + wave * 10;
            enemySpawnInterval = 2000;
            lastEnemySpawn = Date.now();
            bossSpawned = false;
            gameOver = false;
            invincible = false;
            exp = 0;
            level = 0;
            bulletDamage = 5;
            shotgun = 0;
            rpm = 0;
            burst = 0;
            hermes = 0;
            magnetic = 0;
            range = 0;
            damage = 0;
            expToNextLevel = 20;
            startTime = Date.now();
            gameOverScreen.style.display = 'none';
            levelUpScreen.style.display = 'none';
            mainMenu.style.display = 'none';
            bgm.play();
            updateSkillsLabel();
            bulletDamageLabel.textContent = `Bullet Damage: ${bulletDamage}`;
            generateRandomObjects();
        }

        function generateRandomObjects() {
            const objectSizes = {
                tree: { width: 50, height: 50 }
            };
            trees.length = 0;

            for (let i = 0; i < 8; i++) {
                let pos;
                do {
                    pos = getRandomPosition(objectSizes.tree.width, objectSizes.tree.height);
                } while (isOverlapping(pos, objectSizes.tree.width, objectSizes.tree.height));
                trees.push({ ...pos, width: objectSizes.tree.width, height: objectSizes.tree.height });
            }
        }

        function getRandomPosition(width, height) {
            return {
                x: Math.random() * (mapSize - width),
                y: Math.random() * (mapSize - height)
            };
        }

        function isOverlapping(pos, width, height) {
            for (let obj of trees) {
                if (pos.x < obj.x + obj.width &&
                    pos.x + width > obj.x &&
                    pos.y < obj.y + obj.height &&
                    pos.y + height > obj.y) {
                    return true;
                }
            }
            return false;
        }

        function gameLoop() {
            if (!gameOver) {
                update();
                draw();
                requestAnimationFrame(gameLoop);
            }
        }

        function update() {
            elapsedTime = Math.floor((Date.now() - startTime) / 1000);
            let waveTimeLeft = Math.max(0, waveTime - elapsedTime);
            statusLabel.textContent = `Time: ${elapsedTime}s | Wave: ${wave} | Time until next wave: ${waveTimeLeft}s`;
            enemyCountLabel.textContent = `Enemies: ${enemies.length}`;
            if (Date.now() - lastEnemySpawn > enemySpawnInterval) {
                spawnEnemy();
                lastEnemySpawn = Date.now();
            }
            if (wave % 5 === 0 && !bossSpawned) {
                spawnBoss();
                bossSpawned = true;
            }
            movePlayer();
            moveEnemies();
            moveBullets();
            checkCollisions();
            checkExpOrbs();
            checkMedKits();
            checkWave();
            autoShoot();
            if (invincible) {
                invincibleTimer -= 1;
                if (invincibleTimer <= 0) {
                    invincible = false;
                }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(canvas.width / 2 - player.x, canvas.height / 2 - player.y);
            drawMap();
            drawTrees();
            drawPlayer();
            drawEnemies();
            drawBullets();
            drawExpOrbs();
            drawMedKits();
            drawIndicators();
            ctx.restore();
            drawHealthBar();
            drawExpBar();
        }

        function drawMap() {
            ctx.strokeStyle = 'white';
            ctx.strokeRect(0, 0, mapSize, mapSize);
        }

        function drawTrees() {
            trees.forEach(tree => {
                ctx.fillStyle = 'green';
                ctx.fillRect(tree.x, tree.y, tree.width, tree.height);
            });
        }

        function movePlayer() {
            let moved = false;
            let nextX = player.x;
            let nextY = player.y;
            if (keys['w']) {
                nextY -= player.speed * (1 + hermes * 0.05);
                moved = true;
            }
            if (keys['s']) {
                nextY += player.speed * (1 + hermes * 0.05);
                moved = true;
            }
            if (keys['a']) {
                nextX -= player.speed * (1 + hermes * 0.05);
                moved = true;
            }
            if (keys['d']) {
                nextX += player.speed * (1 + hermes * 0.05);
                moved = true;
            }

            if (!isCollidingWithTrees(nextX, nextY)) {
                player.x = nextX;
                player.y = nextY;
            }

            if (player.x < 0) player.x = 0;
            if (player.y < 0) player.y = 0;
            if (player.x > mapSize - player.size) player.x = mapSize - player.size;
            if (player.y > mapSize - player.size) player.y = mapSize - player.size;
        }

        function isCollidingWithTrees(x, y) {
            for (let tree of trees) {
                if (x < tree.x + tree.width &&
                    x + player.size > tree.x &&
                    y < tree.y + tree.height &&
                    y + player.size > tree.y) {
                    return true;
                }
            }
            return false;
        }

        function drawPlayer() {
            ctx.fillStyle = invincible ? (Date.now() % 100 < 50 ? 'white' : 'transparent') : 'white';
            ctx.fillRect(player.x, player.y, player.size, player.size);
        }

        function spawnEnemy() {
            let size = 20;
            let x, y;
            do {
                x = Math.random() * (mapSize - size);
                y = Math.random() * (mapSize - size);
            } while (Math.abs(x - player.x) < 80 && Math.abs(y - player.y) < 80); // 플레이어 주변 80px 이내에 스폰되지 않도록

            let speed = 0.7;
            let health = 10 + (wave - 1) * 2;
            let color;
            if (health <= 10) color = 'red';
            else if (health <= 20) color = 'orange';
            else if (health <= 30) color = 'yellow';
            else if (health <= 40) color = 'green';
            else if (health <= 50) color = 'blue';
            else if (health <= 60) color = 'navy';
            else color = 'purple';
            enemies.push({ x, y, size, speed, health, color, isBoss: false, isArcher: false });
        }

        function spawnBoss() {
            let size = 40;
            let x, y;
            do {
                x = Math.random() * (mapSize - size);
                y = Math.random() * (mapSize - size);
            } while (Math.abs(x - player.x) < 80 && Math.abs(y - player.y) < 80); // 플레이어 주변 80px 이내에 스폰되지 않도록

            let speed = 0.2;
            let health = 100;
            enemies.push({ x, y, size, speed, health, color: 'rgba(0, 255, 0, 0.8)', isBoss: true, lastAttackTime: 0 });
        }

        function moveEnemies() {
            enemies.forEach(enemy => {
                let dx = player.x - enemy.x;
                let dy = player.y - enemy.y;
                let distance = Math.sqrt(dx * dx + dy * dy);
                if (enemy.isBoss && Date.now() - enemy.lastAttackTime > 10000) {
                    enemy.lastAttackTime = Date.now();
                    // 보스 돌진 로직
                    enemy.x += (dx / distance) * 10;
                    enemy.y += (dy / distance) * 10;
                } else {
                    enemy.x += (dx / distance) * enemy.speed;
                    enemy.y += (dy / distance) * enemy.speed;
                }
            });
        }

        function drawEnemies() {
            enemies.forEach(enemy => {
                if (enemy.isArcher) {
                    ctx.fillStyle = enemy.color;
                    ctx.beginPath();
                    ctx.moveTo(enemy.x, enemy.y);
                    ctx.lineTo(enemy.x + enemy.size, enemy.y);
                    ctx.lineTo(enemy.x + enemy.size / 2, enemy.y - enemy.size);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    ctx.fillStyle = enemy.color;
                    ctx.fillRect(enemy.x, enemy.y, enemy.size, enemy.size);
                }

                // Draw health bar
                ctx.fillStyle = 'black';
                ctx.fillRect(enemy.x, enemy.y - 10, enemy.size, 5);
                ctx.fillStyle = 'red';
                ctx.fillRect(enemy.x, enemy.y - 10, enemy.size * (enemy.health / (10 + (wave - 1) * 2)), 5);
            });
        }

        function shootBullet(x, y, angle) {
            laserSound.play();
            for (let i = 0; i <= burst; i++) {
                setTimeout(() => {
                    let damage = shotgun > 0 ? bulletDamage / (1 + shotgun * 2) * 1.4 : bulletDamage;
                    let initialSize = 10;
                    let bullet = { x: player.x + player.size / 2, y: player.y + player.size / 2, angle, speed: 5, penetration: 0, damage, size: initialSize, initialSize, createdTime: Date.now() };
                    bullets.push(bullet);
                    for (let j = 1; j <= shotgun; j++) {
                        bullets.push({ ...bullet, angle: angle + j * 0.1 });
                        bullets.push({ ...bullet, angle: angle - j * 0.1 });
                    }
                }, i * 100);
            }
        }

        function moveBullets() {
            bullets.forEach((bullet, index) => {
                bullet.x += Math.cos(bullet.angle) * bullet.speed;
                bullet.y += Math.sin(bullet.angle) * bullet.speed;
                bullet.size = bullet.initialSize * Math.max(0, 1 - (Date.now() - bullet.createdTime) / 1000); // 점점 작아짐
                if (bullet.size <= 0 || isCollidingWithTrees(bullet.x, bullet.y) || bullet.x < 0 || bullet.x > mapSize || bullet.y < 0 || bullet.y > mapSize) {
                    bullets.splice(index, 1);
                }
            });
        }

        function drawBullets() {
            bullets.forEach(bullet => {
                ctx.fillStyle = bullet.isArrow ? 'blue' : 'yellow';
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function checkCollisions() {
            enemies.forEach((enemy, enemyIndex) => {
                if (player.x < enemy.x + enemy.size &&
                    player.x + player.size > enemy.x &&
                    player.y < enemy.y + enemy.size &&
                    player.y + player.size > enemy.y) {
                    if (!invincible) {
                        player.health -= enemy.isBoss ? 20 : 10;
                        invincible = true;
                        invincibleTimer = 60; // 1초 (60 프레임)
                        if (player.health <= 0) {
                            player.health = 0;
                            endGame();
                        }
                    }
                }
                bullets.forEach((bullet, bulletIndex) => {
                    if (bullet.x < enemy.x + enemy.size &&
                        bullet.x + bullet.size > enemy.x &&
                        bullet.y < enemy.y + enemy.size &&
                        bullet.y + bullet.size > enemy.y) {
                        enemy.health -= bullet.damage;
                        bullets.splice(bulletIndex, 1);
                        if (enemy.health <= 0) {
                            enemies.splice(enemyIndex, 1);
                            if (Math.random() < 0.7) { // 70% 확률로 경험치 드랍
                                spawnExpOrb(enemy.x, enemy.y, 'green');
                            } else if (Math.random() < 0.1) { // 10% 확률로 고급 경험치 드랍
                                spawnExpOrb(enemy.x, enemy.y, 'orange');
                            } else if (Math.random() < 0.05) { // 5% 확률로 전설 경험치 드랍
                                spawnExpOrb(enemy.x, enemy.y, 'pink');
                            }
                            if (Math.random() < 0.05) { // 5% 확률로 구급상자 드랍
                                spawnMedKit(enemy.x, enemy.y);
                            }
                        }
                    }
                });
            });
        }

        function spawnExpOrb(x, y, color) {
            let value;
            if (color === 'green') value = 15;
            else if (color === 'orange') value = 30;
            else if (color === 'pink') value = 60;

            expOrbs.push({ x, y, size: 10, color, value, createdAt: Date.now() });
        }

        function moveExpOrbs() {
            expOrbs.forEach((orb, index) => {
                if (Date.now() - orb.createdAt > 30000) {
                    expOrbs.splice(index, 1);
                    return;
                }
                let dx = player.x - orb.x;
                let dy = player.y - orb.y;
                let distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < 50 * (1 + magnetic * 0.1)) {
                    orb.x += (dx / distance) * 5;
                    orb.y += (dy / distance) * 5;
                }
                if (distance < player.size) {
                    expOrbs.splice(index, 1);
                    exp += orb.value;
                    if (exp >= expToNextLevel) {
                        levelUp();
                    }
                }
            });
        }

        function drawExpOrbs() {
            expOrbs.forEach(orb => {
                ctx.fillStyle = orb.color;
                ctx.fillRect(orb.x, orb.y, orb.size, orb.size);
            });
        }

        function checkExpOrbs() {
            moveExpOrbs();
        }

        function spawnMedKit(x, y) {
            medKits.push({ x, y, size: 10, createdAt: Date.now() });
        }

        function moveMedKits() {
            medKits.forEach((kit, index) => {
                if (Date.now() - kit.createdAt > 30000) {
                    medKits.splice(index, 1);
                    return;
                }
                let dx = player.x - kit.x;
                let dy = player.y - kit.y;
                let distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < 50 * (1 + magnetic * 0.1)) {
                    kit.x += (dx / distance) * 5;
                    kit.y += (dy / distance) * 5;
                }
                if (distance < player.size) {
                    medKits.splice(index, 1);
                    player.health = Math.min(player.health + 10, 100);
                }
            });
        }

        function drawMedKits() {
            ctx.fillStyle = 'red';
            medKits.forEach(kit => {
                ctx.fillRect(kit.x, kit.y, kit.size, kit.size);
            });
        }

        function checkMedKits() {
            moveMedKits();
        }

        function drawHealthBar() {
            const barWidth = 200;
            const barHeight = 20;
            const barX = (canvas.width - barWidth) / 2;
            const barY = canvas.height - 40;

            ctx.fillStyle = 'black';
            ctx.fillRect(barX, barY, barWidth, barHeight);

            const healthWidth = (player.health / 100) * barWidth;
            ctx.fillStyle = 'green';
            ctx.fillRect(barX, barY, healthWidth, barHeight);

            ctx.strokeStyle = 'white';
            ctx.strokeRect(barX, barY, barWidth, barHeight);
        }

        function drawExpBar() {
            const barWidth = 200;
            const barHeight = 20;
            const barX = (canvas.width - barWidth) / 2;
            const barY = canvas.height - 70;

            ctx.fillStyle = 'black';
            ctx.fillRect(barX, barY, barWidth, barHeight);

            const expWidth = (exp / expToNextLevel) * barWidth;
            ctx.fillStyle = 'blue';
            ctx.fillRect(barX, barY, expWidth, barHeight);

            ctx.strokeStyle = 'white';
            ctx.strokeRect(barX, barY, barWidth, barHeight);

            ctx.fillStyle = 'white';
            ctx.font = '16px Arial';
            ctx.fillText(`Level: ${level}`, barX + barWidth / 2 - 20, barY + 15);
        }

        function levelUp() {
            level += 1;
            exp = 0;
            expToNextLevel += 10;
            levelUpScreen.style.display = 'flex';
            gameOver = true; // 일시정지

            const availableSkills = ['shotgun', 'rpm', 'burst', 'hermes', 'magnetic', 'range', 'damage'];
            const selectedSkills = [];
            while (selectedSkills.length < 3) {
                const skill = availableSkills[Math.floor(Math.random() * availableSkills.length)];
                if (!selectedSkills.includes(skill)) {
                    selectedSkills.push(skill);
                }
            }

            skillButtons.forEach(button => {
                const skill = button.getAttribute('data-skill');
                if (selectedSkills.includes(skill)) {
                    button.style.display = 'block';
                    skillDescriptions.forEach(desc => {
                        if (desc.getAttribute('data-skill') === skill) {
                            desc.style.display = 'block';
                        } else {
                            desc.style.display = 'none';
                        }
                    });
                } else {
                    button.style.display = 'none';
                }
            });
        }

        function updateSkillsLabel() {
            skillsLabel.innerHTML = `Shotgun: ${shotgun}<br>RPM: ${rpm}<br>Burst: ${burst}<br>Hermes: ${hermes}<br>Magnetic: ${magnetic}<br>Range: ${range}<br>Damage: ${damage}`;
        }

        skillButtons.forEach(button => {
            button.addEventListener('click', () => {
                const skill = button.getAttribute('data-skill');
                if (skill === 'shotgun' && shotgun < 10) {
                    shotgun += 1;
                } else if (skill === 'rpm' && rpm < 10) {
                    rpm += 1;
                } else if (skill === 'burst' && burst < 10) {
                    burst += 1;
                } else if (skill === 'hermes' && hermes < 10) {
                    hermes += 1;
                } else if (skill === 'magnetic' && magnetic < 10) {
                    magnetic += 1;
                } else if (skill === 'range' && range < 10) {
                    range += 1;
                    player.viewRange += 50;
                } else if (skill === 'damage' && damage < 10) {
                    damage += 1;
                    bulletDamage += 10;
                    bulletDamageLabel.textContent = `Bullet Damage: ${bulletDamage}`;
                }
                updateSkillsLabel();
                gameOver = false;
                levelUpScreen.style.display = 'none';
                requestAnimationFrame(gameLoop);
            });
        });

        function checkWave() {
            if (elapsedTime >= waveTime || enemies.length === 0) {
                wave += 1;
                waveTime = 30 + wave * 10;
                spawnWaveEnemies();
                bossSpawned = false;
            }
        }

        function spawnWaveEnemies() {
            let enemiesToSpawn = wave * 3 + 15;
            while (enemiesToSpawn > 0) {
                spawnEnemy();
                enemiesToSpawn -= 1;
            }
            // 웨이브마다 Archer 수 제한
            if (wave % 2 === 0) {
                let archersToSpawn = Math.min(5, Math.floor(wave / 2));
                while (archersToSpawn > 0) {
                    spawnArcher();
                    archersToSpawn -= 1;
                }
            }
        }

        function spawnArcher() {
            let size = 20;
            let x, y;
            do {
                x = Math.random() * (mapSize - size);
                y = Math.random() * (mapSize - size);
            } while (Math.abs(x - player.x) < 80 && Math.abs(y - player.y) < 80); // 플레이어 주변 80px 이내에 스폰되지 않도록

            let speed = 0.35;
            let health = 10 + (wave - 1) * 2;
            enemies.push({ x, y, size, speed, health, color: 'red', isBoss: false, isArcher: true });
        }

        function autoShoot() {
            if (Date.now() - lastShot > 1000 / (1 + rpm * 0.2)) {
                const angle = Math.atan2(mouseY - (canvas.height / 2), mouseX - (canvas.width / 2));
                shootBullet(player.x + player.size / 2, player.y + player.size / 2, angle);
                lastShot = Date.now();
            }
        }

        function drawIndicators() {
            if (enemies.length <= 5) {
                enemies.forEach(enemy => {
                    let dx = enemy.x - player.x;
                    let dy = enemy.y - player.y;
                    let angle = Math.atan2(dy, dx);
                    ctx.fillStyle = 'red';
                    ctx.beginPath();
                    ctx.arc(player.x + Math.cos(angle) * 50, player.y + Math.sin(angle) * 50, 5, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
        }

        function endGame() {
            gameOver = true;
            gameOverScreen.style.display = 'flex';
            bgm.pause();
        }

        restartButton.addEventListener('click', () => {
            initializeGame();
            gameLoop();
        });

        playButton.addEventListener('click', () => {
            mainMenu.style.display = 'none';
            initializeGame();
            gameLoop();
        });

        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        function showMainMenu() {
            mainMenu.style.display = 'flex';
            bgm.play();
            // 메인 화면 배경 적 생성
            const backgroundEnemies = [];
            for (let i = 0; i < 10; i++) {
                backgroundEnemies.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, size: 20, speed: 0.5 + Math.random() * 0.5 });
            }

            function drawBackgroundEnemies() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                backgroundEnemies.forEach(enemy => {
                    enemy.x += (Math.random() - 0.5) * enemy.speed;
                    enemy.y += (Math.random() - 0.5) * enemy.speed;
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                    ctx.fillRect(enemy.x, enemy.y, enemy.size, enemy.size);
                });
                if (mainMenu.style.display === 'flex') {
                    requestAnimationFrame(drawBackgroundEnemies);
                }
            }
            drawBackgroundEnemies();
        }

        showMainMenu();
    </script>
</body>
</html>
